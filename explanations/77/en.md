## Explanation

### Strategy (The "Why")

**1.1 Constraints & Complexity**

* **Input Range:** $n$ is between 1 and 20, and $k$ is between 1 and $n$.
* **Time Complexity:** $O(C(n,k) \times k)$ where $C(n,k)$ is the binomial coefficient (number of combinations). Each combination takes $O(k)$ to build.
* **Space Complexity:** $O(C(n,k) \times k)$ for storing all combinations, plus $O(k)$ for the recursion stack.
* **Edge Case:** When $k = 1$, we return all numbers from 1 to $n$ as separate combinations. When $k = n$, we return a single combination containing all numbers.

**1.2 High-level approach**

The goal is to generate all possible combinations of $k$ numbers chosen from the range $[1, n]$. We use backtracking to build combinations incrementally, ensuring we only generate valid combinations without duplicates.

![Backtracking tree visualization showing how combinations are generated by selecting numbers]

**1.3 Brute force vs. optimized strategy**

* **Brute Force:** Generate all possible subsets of size $k$ and filter out invalid ones. This generates $2^n$ subsets, most of which are the wrong size.
* **Optimized (Backtracking):** Use backtracking to build combinations of exactly size $k$ by selecting numbers in order. This only generates valid combinations and avoids duplicates by always selecting numbers in increasing order.

**1.4 Decomposition**

1. Use backtracking to build combinations number by number.
2. Start from a given number and try adding each subsequent number.
3. When the combination reaches size $k$, add it to the result.
4. Backtrack by removing the last number and trying the next one.
5. Ensure numbers are always in increasing order to avoid duplicates.

### Steps (The "How")

**2.1 Initialization & Example Setup**

Let's use the example $n = 4$, $k = 2$.

We initialize:
* `res = []` (list to store all combinations)
* `current_combination = []` (current combination being built)
* `start = 1` (smallest number to consider)

**2.2 Start Checking/Processing**

We call the backtrack function with `start = 1` and empty combination.

**2.3 Trace Walkthrough**

The backtracking process builds combinations recursively:

| Step | start | current_combination | Action | Result |
|------|-------|---------------------|--------|--------|
| 1 | 1 | [] | Add 1 | [1] |
| 2 | 2 | [1] | Add 2 | [1,2] → Add to res |
| 3 | 3 | [1] | Add 3 | [1,3] → Add to res |
| 4 | 4 | [1] | Add 4 | [1,4] → Add to res |
| 5 | 2 | [] | Add 2 | [2] |
| 6 | 3 | [2] | Add 3 | [2,3] → Add to res |
| 7 | 4 | [2] | Add 4 | [2,4] → Add to res |
| 8 | 3 | [] | Add 3 | [3] |
| 9 | 4 | [3] | Add 4 | [3,4] → Add to res |

**2.4 Increment and Loop**

The backtracking function:
1. Base case: If `len(current_combination) == k`, add a copy to `res` and return.
2. For each number $i$ from `start` to $n$:
   - Add $i$ to `current_combination`
   - Recursively call with `start = i + 1`
   - Remove $i$ from `current_combination` (backtrack)

**2.5 Return Result**

After backtracking completes, `res = [[1,2], [1,3], [1,4], [2,3], [2,4], [3,4]]`, containing all 6 combinations of 2 numbers chosen from [1, 2, 3, 4].

