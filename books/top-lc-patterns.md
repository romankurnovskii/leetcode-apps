Top 20 LeetCode Patterns

Arrays & Hashing: Using arrays, hash maps (dictionaries), or hash sets to store and retrieve data efficiently. This is foundational for problems involving frequency counts, lookups, or grouping elements.

Two Pointers: Employing two pointers to iterate through a data structure (usually an array) until they meet or cross. It's highly effective for problems on sorted arrays that involve finding pairs, triplets, or a subarray with a certain property.

Sliding Window: A variation of the Two Pointers technique where a "window" (a subarray or substring) is moved over the data. This pattern is ideal for finding the optimal value (like the longest, shortest, or most) within a contiguous part of a sequence.

Stack: Using a Last-In-First-Out (LIFO) data structure. This is the go-to pattern for problems involving nested structures like matching parentheses, parsing expressions, and finding the next greater element.

Binary Search: A fast search algorithm for sorted arrays. It works by repeatedly dividing the search interval in half. It's used not only for finding an element but also for finding the minimum or maximum value that satisfies a specific condition.

Linked List: Problems focused on the linked list data structure. Common sub-patterns include reversing a list, detecting cycles (Floyd's Tortoise and Hare), merging, and removing nodes.

Trees: A broad category for problems involving tree data structures. It includes traversing trees (in-order, pre-order, post-order), finding depths, validating structures (like a Binary Search Tree), and finding common ancestors.

Graphs: Problems modeled as a set of nodes (vertices) connected by edges. This pattern involves representing the graph (adjacency list or matrix) and applying traversal or other algorithms to find paths, cycles, or connectivity.

Graph Traversal (BFS & DFS): Core algorithms for exploring a graph. Breadth-First Search (BFS) explores layer by layer, perfect for finding the shortest path in unweighted graphs. Depth-First Search (DFS) explores as far as possible down one branch before backtracking, often used for pathfinding and cycle detection.

Tries (Prefix Trees): A specialized tree structure used for efficient retrieval of strings based on their prefixes. It's the optimal pattern for problems involving word searches, autocomplete features, and IP routing.

Heap / Priority Queue: A tree-based data structure that satisfies the heap property. It's essential for problems that require efficiently finding the smallest or largest element among a dynamic set, such as finding the "Kth-largest" element, scheduling tasks, or implementing Dijkstra's algorithm.

Backtracking: An algorithmic technique for solving problems recursively by trying to build a solution incrementally. When a candidate solution fails to satisfy the conditions, you "backtrack" to the previous step and try a different path. It's used for generating all possible solutions like subsets, permutations, and combinations.

Dynamic Programming (DP): An optimization technique for problems with overlapping subproblems and optimal substructure. It involves breaking down a complex problem into simpler subproblems, solving each subproblem just once, and storing their solutions.

Greedy Algorithms: Building up a solution piece by piece, always choosing the next piece that offers the most obvious and immediate benefit. This approach works when a locally optimal choice leads to a globally optimal solution.

Intervals: A common problem type involving a list of intervals (start and end times). Typical tasks include merging overlapping intervals, inserting a new interval, or finding non-overlapping intervals.

Bit Manipulation: Solving problems by working directly with the binary representation of numbers using bitwise operators (&, |, ^, ~, <<, >>). This can lead to highly efficient solutions for problems involving sets, missing numbers, or powers of two.

Union-Find (Disjoint Set Union): A data structure that tracks a set of elements partitioned into a number of disjoint (non-overlapping) subsets. Its primary use is to determine if two elements are in the same subset or to merge two subsets, often applied to graph connectivity problems.

Topological Sort: An algorithm for ordering the vertices in a directed acyclic graph (DAG) such that for every directed edge from node A to node B, node A comes before node B in the ordering. It's commonly used in task scheduling or dependency resolution.

Dijkstra's Algorithm: A classic graph algorithm for finding the shortest paths between nodes in a weighted graph, where all edge weights are non-negative. It's often implemented using a priority queue.

Math & Geometry: A category for problems that require knowledge of number theory (prime numbers, GCD), combinatorics (permutations, combinations), probability, or geometric concepts (points, lines, shapes).